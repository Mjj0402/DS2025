#include <iostream>
#include <vector>
#include <random>
#include <chrono>
#include <algorithm>
#include <cmath>
#include <iomanip>

// 定义边界框结构体
struct BoundingBox {
    float x1, y1;  // 左上角坐标
    float x2, y2;  // 右下角坐标
    float score;   // 置信度

    // 用于排序的比较（降序）
    bool operator<(const BoundingBox& other) const {
        return score < other.score;
    }
    bool operator>(const BoundingBox& other) const {
        return score > other.score;
    }
};

// 计算两个边界框的交并比（IoU）
float calculateIoU(const BoundingBox& a, const BoundingBox& b) {
    // 计算交集的坐标
    float interX1 = std::max(a.x1, b.x1);
    float interY1 = std::max(a.y1, b.y1);
    float interX2 = std::min(a.x2, b.x2);
    float interY2 = std::min(a.y2, b.y2);

    // 交集的宽和高（如果为负，说明无交集）
    float interWidth = std::max(0.0f, interX2 - interX1);
    float interHeight = std::max(0.0f, interY2 - interY1);
    float interArea = interWidth * interHeight;

    // 计算两个框的面积
    float areaA = (a.x2 - a.x1) * (a.y2 - a.y1);
    float areaB = (b.x2 - b.x1) * (b.y2 - b.y1);

    // 计算并集面积
    float unionArea = areaA + areaB - interArea;

    if (unionArea == 0) {
        return 0.0f;
    }

    return interArea / unionArea;
}

// ---------------------- 排序算法实现 ----------------------
// 1. 冒泡排序（降序，基于置信度）
void bubbleSort(std::vector<BoundingBox>& boxes) {
    int n = boxes.size();
    for (int i = 0; i < n - 1; ++i) {
        bool swapped = false;
        for (int j = 0; j < n - i - 1; ++j) {
            if (boxes[j].score < boxes[j + 1].score) {
                std::swap(boxes[j], boxes[j + 1]);
                swapped = true;
            }
        }
        if (!swapped) {
            break; // 提前退出，优化性能
        }
    }
}

// 2. 插入排序（降序，基于置信度）
void insertionSort(std::vector<BoundingBox>& boxes) {
    int n = boxes.size();
    for (int i = 1; i < n; ++i) {
        BoundingBox key = boxes[i];
        int j = i - 1;
        // 将比key小的元素后移
        while (j >= 0 && boxes[j].score < key.score) {
            boxes[j + 1] = boxes[j];
            j--;
        }
        boxes[j + 1] = key;
    }
}

// 归并排序的辅助函数：合并两个有序子数组
void merge(std::vector<BoundingBox>& boxes, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    // 临时数组
    std::vector<BoundingBox> L(n1), R(n2);
    for (int i = 0; i < n1; ++i) {
        L[i] = boxes[left + i];
    }
    for (int j = 0; j < n2; ++j) {
        R[j] = boxes[mid + 1 + j];
    }

    // 合并临时数组到原数组
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i].score >= R[j].score) {
            boxes[k] = L[i];
            i++;
        } else {
            boxes[k] = R[j];
            j++;
        }
        k++;
    }

    // 复制剩余元素
    while (i < n1) {
        boxes[k] = L[i];
        i++;
        k++;
    }
    while (j < n2) {
        boxes[k] = R[j];
        j++;
        k++;
    }
}

// 3. 归并排序（降序，基于置信度）
void mergeSort(std::vector<BoundingBox>& boxes, int left, int right) {
    if (left >= right) {
        return;
    }
    int mid = left + (right - left) / 2;
    mergeSort(boxes, left, mid);
    mergeSort(boxes, mid + 1, right);
    merge(boxes, left, mid, right);
}

// 归并排序的对外接口（简化调用）
void mergeSort(std::vector<BoundingBox>& boxes) {
    if (boxes.empty()) {
        return;
    }
    mergeSort(boxes, 0, boxes.size() - 1);
}

// 快速排序的辅助函数：划分操作
int partition(std::vector<BoundingBox>& boxes, int low, int high) {
    // 选择最后一个元素作为基准
    float pivot = boxes[high].score;
    int i = low - 1; // 小于基准的元素的索引

    for (int j = low; j < high; ++j) {
        if (boxes[j].score >= pivot) { // 降序，大于等于基准的放左边
            i++;
            std::swap(boxes[i], boxes[j]);
        }
    }
    std::swap(boxes[i + 1], boxes[high]);
    return i + 1;
}

// 4. 快速排序（降序，基于置信度）
void quickSort(std::vector<BoundingBox>& boxes, int low, int high) {
    if (low < high) {
        int pi = partition(boxes, low, high);
        quickSort(boxes, low, pi - 1);
        quickSort(boxes, pi + 1, high);
    }
}

// 快速排序的对外接口（简化调用）
void quickSort(std::vector<BoundingBox>& boxes) {
    if (boxes.empty()) {
        return;
    }
    quickSort(boxes, 0, boxes.size() - 1);
}

// ---------------------- 数据生成函数 ----------------------
// 生成随机分布的边界框
std::vector<BoundingBox> generateRandomBoxes(int num, float imgWidth = 800.0f, float imgHeight = 600.0f) {
    std::vector<BoundingBox> boxes;
    boxes.reserve(num);

    // 随机数生成器
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<float> distX(0.0f, imgWidth);
    std::uniform_real_distribution<float> distY(0.0f, imgHeight);
    std::uniform_real_distribution<float> distSize(10.0f, 100.0f); // 框的最小尺寸10，最大100
    std::uniform_real_distribution<float> distScore(0.0f, 1.0f);   // 置信度0~1

    for (int i = 0; i < num; ++i) {
        float x1 = distX(gen);
        float y1 = distY(gen);
        // 确保x2 > x1，y2 > y1
        float x2 = std::min(x1 + distSize(gen), imgWidth);
        float y2 = std::min(y1 + distSize(gen), imgHeight);
        float score = distScore(gen);

        boxes.push_back({x1, y1, x2, y2, score});
    }

    return boxes;
}

// 生成聚集分布的边界框（围绕若干个中心点聚集）
std::vector<BoundingBox> generateClusteredBoxes(int num, int clusterNum = 5, float imgWidth = 800.0f, float imgHeight = 600.0f) {
    std::vector<BoundingBox> boxes;
    boxes.reserve(num);

    // 随机数生成器
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<float> distCenterX(50.0f, imgWidth - 50.0f);
    std::uniform_real_distribution<float> distCenterY(50.0f, imgHeight - 50.0f);
    std::normal_distribution<float> distOffsetX(0.0f, 30.0f); // 正态分布，聚集在中心点周围
    std::normal_distribution<float> distOffsetY(0.0f, 30.0f);
    std::uniform_real_distribution<float> distSize(10.0f, 80.0f);
    std::uniform_real_distribution<float> distScore(0.0f, 1.0f);

    // 生成聚类中心点
    std::vector<std::pair<float, float>> centers;
    for (int i = 0; i < clusterNum; ++i) {
        centers.emplace_back(distCenterX(gen), distCenterY(gen));
    }

    for (int i = 0; i < num; ++i) {
        // 随机选择一个聚类中心
        int centerIdx = rand() % clusterNum;
        float centerX = centers[centerIdx].first;
        float centerY = centers[centerIdx].second;

        // 生成偏移后的坐标（确保在图像范围内）
        float x1 = std::max(0.0f, std::min(centerX + distOffsetX(gen), imgWidth - 10.0f));
        float y1 = std::max(0.0f, std::min(centerY + distOffsetY(gen), imgHeight - 10.0f));
        float x2 = std::min(x1 + distSize(gen), imgWidth);
        float y2 = std::min(y1 + distSize(gen), imgHeight);
        float score = distScore(gen);

        boxes.push_back({x1, y1, x2, y2, score});
    }

    return boxes;
}

// ---------------------- NMS算法实现 ----------------------
// 基础NMS算法（传入排序后的边界框，返回筛选后的结果）
std::vector<BoundingBox> nonMaximumSuppression(std::vector<BoundingBox> boxes, float iouThreshold = 0.5f) {
    std::vector<BoundingBox> result;
    if (boxes.empty()) {
        return result;
    }

    // 遍历排序后的边界框
    while (!boxes.empty()) {
        // 取置信度最高的框
        BoundingBox topBox = boxes[0];
        result.push_back(topBox);

        // 移除当前最高置信度的框，筛选剩余不重叠的框
        std::vector<BoundingBox> remainingBoxes;
        for (size_t i = 1; i < boxes.size(); ++i) {
            if (calculateIoU(topBox, boxes[i]) < iouThreshold) {
                remainingBoxes.push_back(boxes[i]);
            }
        }

        boxes = remainingBoxes;
    }

    return result;
}

// 测试排序算法性能的函数（返回运行时间，单位：毫秒）
template <typename SortFunc>
double testSortPerformance(SortFunc sortFunc, std::vector<BoundingBox> boxes, float iouThreshold = 0.5f) {
    // 记录开始时间
    auto start = std::chrono::high_resolution_clock::now();

    // 执行排序
    sortFunc(boxes);

    // 执行NMS（模拟实际应用场景）
    auto result = nonMaximumSuppression(boxes, iouThreshold);

    // 记录结束时间
    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double, std::milli> duration = end - start;

    return duration.count();
}

int main() {
    // 测试的数据集规模（100, 1000, 5000, 10000）
    std::vector<int> sizes = {100, 1000, 5000, 10000};
    // IoU阈值
    const float iouThreshold = 0.5f;

    std::cout << std::fixed << std::setprecision(3);

    // 测试随机分布的边界框
    std::cout << "========== 随机分布的边界框性能测试 ==========\n";
    for (int size : sizes) {
        std::cout << "\n数据规模：" << size << " 个边界框\n";
        std::vector<BoundingBox> boxes = generateRandomBoxes(size);

        // 冒泡排序
        double bubbleTime = testSortPerformance(bubbleSort, boxes, iouThreshold);
        std::cout << "冒泡排序 + NMS 耗时：" << bubbleTime << " ms\n";

        // 插入排序
        double insertionTime = testSortPerformance(insertionSort, boxes, iouThreshold);
        std::cout << "插入排序 + NMS 耗时：" << insertionTime << " ms\n";

        // 归并排序
        double mergeTime = testSortPerformance(mergeSort, boxes, iouThreshold);
        std::cout << "归并排序 + NMS 耗时：" << mergeTime << " ms\n";

        // 快速排序
        double quickTime = testSortPerformance(quickSort, boxes, iouThreshold);
        std::cout << "快速排序 + NMS 耗时：" << quickTime << " ms\n";
    }

    // 测试聚集分布的边界框
    std::cout << "\n========== 聚集分布的边界框性能测试 ==========\n";
    for (int size : sizes) {
        std::cout << "\n数据规模：" << size << " 个边界框\n";
        std::vector<BoundingBox> boxes = generateClusteredBoxes(size);

        // 冒泡排序
        double bubbleTime = testSortPerformance(bubbleSort, boxes, iouThreshold);
        std::cout << "冒泡排序 + NMS 耗时：" << bubbleTime << " ms\n";

        // 插入排序
        double insertionTime = testSortPerformance(insertionSort, boxes, iouThreshold);
        std::cout << "插入排序 + NMS 耗时：" << insertionTime << " ms\n";

        // 归并排序
        double mergeTime = testSortPerformance(mergeSort, boxes, iouThreshold);
        std::cout << "归并排序 + NMS 耗时：" << mergeTime << " ms\n";

        // 快速排序
        double quickTime = testSortPerformance(quickSort, boxes, iouThreshold);
        std::cout << "快速排序 + NMS 耗时：" << quickTime << " ms\n";
    }

    return 0;
}
